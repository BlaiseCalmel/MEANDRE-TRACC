<!DOCTYPE html>
<html lang="fr">
    <head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Abigail</title>

	<!-- topojson for json -->
	<script src="//d3js.org/topojson.v1.min.js"></script>
	<!-- geotoolbox for geo transformation -->
	<script src="https://cdn.jsdelivr.net/npm/geotoolbox" charset="utf-8"></script>

	<!-- d3 -->
	<script src="https://d3js.org/d3.v6.min.js"></script>
	<!-- d3 interpolate path -->
	<script src="https://unpkg.com/d3-interpolate-path@2.3.0/build/d3-interpolate-path.js"></script>
	

	<style>
         body {
             margin: 0;
             padding: 0;
             display: flex;
             height: 100vh;
             overflow: hidden;
	     background-color: #333;
         }

         #menu {
             width: 60px;
             background-color: #CCC;
             color: #fff;
             padding: 20px;
             box-shadow: 2px 0px 5px rgba(0, 0, 0, 0.5);
             transition: width 0.3s ease;
             position: absolute;
             top: 0;
             bottom: 0;
             z-index: 2;
         }

         #menu.expanded {
             width: 250px;
         }

         #menu-button {
             cursor: pointer;
             z-index: 3;
             position: absolute;
             top: 20px;
             left: 20px;
         }

         #map-container {
             flex: 1;
	     position: relative;
             overflow: hidden;
         }

	</style>
    </head>
    <body>
	<div id="map-container">
            <svg id="geoJSONsvg_france"></svg>
	</div>
	
	<script>
	 
	 
         function toggleMenu() {
             const menu = document.getElementById("menu");
             const menuText = document.getElementById("menu-text");

             if (menu.classList.contains("expanded")) {
                 menu.classList.remove("expanded");
                 menuText.textContent = "M";
             } else {
                 menu.classList.add("expanded");
                 menuText.textContent = "Menu";
             }
         }

	 

	 const k_simplify_initial = 0.02;

	 const geoJSONfiles = [
	     'data/france.geo.json',
	     'data/river.geo.json'
	 ];

	 function loadGeoJSON(fileURL) {
	     return d3.json(fileURL)
		      .then(data => data)
		      .catch(error => {
			  console.error("Error loading geojson file :", error);
			  throw error;
		      });
	 }

	 const promises = geoJSONfiles.map(fileURL => loadGeoJSON(fileURL));

	 Promise.all(promises)
		.then(geoJSONdata => {
		    const geoJSONdata_france = geotoolbox.simplify(geoJSONdata[0], { k: k_simplify_initial, merge: false });
		    const geoJSONdata_river = geotoolbox.simplify(geoJSONdata[1], { k: k_simplify_initial, merge: false });
		    drawGeoJSON(geoJSONdata_france, geoJSONdata_river);
		})
		.catch(error => {
		    console.error("Error loading or processing GeoJSON files:", error);
		});

	 

	 function drawGeoJSON(geoJSONdata_france, geoJSONdata_river) {
	     if (geoJSONdata_france && geoJSONdata_river) {
		 const width = 700;
		 const height = 700;

		 
		 const landColor = "transparent";
		 const landStroke = "#fff";
		 const stroke_river = "#777";

		 const minZoom = 1;
		 const maxZoom = 4;
		 const maxPan = 0;

		 const transitionDuration = 500;
		 
		 const k_simplify_ref = 0.05;
		 let k_simplify;

		 const riverLength_max = 300000;
		 const riverLength_min = 100000;
		 let riverLength;

		 const zoom = d3.zoom()
				.scaleExtent([minZoom, maxZoom])
				.translateExtent([[-width*maxPan, -height*maxPan],
						  [width*(1+maxPan), height*(1+maxPan)]])
				.on("zoom", function (event) { 

				    riverLength = riverLength_max - (event.transform.k - minZoom)/(maxZoom-minZoom)*(riverLength_max-riverLength_min);
				    
				    k_simplify = k_simplify_ref + (event.transform.k - minZoom)/(maxZoom-minZoom)*(1-k_simplify_ref);
				    redrawMap(k_simplify, riverLength);

				    svg.attr("transform", event.transform);
				    svg.style("width", width * event.transform.k + "px");
				    svg.style("height", height * event.transform.k + "px");
				});


		 const projection = d3.geoMercator()
				      .scale([2200])
				      .center(geoJSONdata_france.features[0].properties.centroid)
				      .translate([width/2, height/2]);

		 const svg = d3.select("#geoJSONsvg_france")
			       .attr("width", width)
			       .attr("height", height)
			       .call(zoom)
			       .append("g");
		 
		 function redrawMap(k_simplify, riverLength) {
		     const simplifiedGeoJSON_france = geotoolbox.simplify(geoJSONdata_france, { k: k_simplify, merge: false });

		     const selectedGeoJSON_river = geotoolbox.filter(geoJSONdata_river, (d) => d.length >= riverLength);
		     const simplifiedselectedGeoJSON_river = geotoolbox.simplify(selectedGeoJSON_river, { k: k_simplify, merge: false });

		     
		     svg.selectAll('path.france')
			.data(simplifiedGeoJSON_france.features)
			.join('path')
			.attr('class', 'france')
			.attr('d', pathGenerator)
			.attr('fill', landColor)
			.attr('stroke', landStroke)
			.attr('stroke-width', 1)
			.attr('stroke-linejoin', "round")
			.attr('stroke-miterlimit', 1);

		     const strokeWith_river_max = 0.9;
		     const strokeWith_river_min = 0.2;
		     
		     svg.selectAll('path.river')
			.data(simplifiedselectedGeoJSON_river.features)
			.join('path')
			.attr('class', 'river')
			.attr('d', pathGenerator)
			.transition()
			.duration(1000)
			.attr("fill", "transparent")
			.attr("stroke", stroke_river)
		     /* .attr('stroke-width', 0.8) */
			.attr("stroke-width", function(d) {
			    return strokeWith_river_max - (1-d.properties.norm)*(strokeWith_river_max-strokeWith_river_min);
			})
			.attr('stroke-linejoin', "round")
			.attr('stroke-linecap', "round")
			.attr('stroke-miterlimit', 1);
		     
		 }

		 const pathGenerator = d3.geoPath(projection);

		 redrawMap(k_simplify_ref, riverLength_max); // Initial map drawing
		 
		 return svg.node();
		 
	     }
	 }
	 
	</script>
    </body>
</html>
