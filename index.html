<!DOCTYPE html>
<html lang="fr">
    <head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Abigail</title>

	<!-- topojson for json -->
	<script src="//d3js.org/topojson.v1.min.js"></script>
	<!-- geotoolbox for geo transformation -->
	<script src="https://cdn.jsdelivr.net/npm/geotoolbox" charset="utf-8"></script>

	<!-- d3 -->
	<script src="https://d3js.org/d3.v6.min.js"></script>
	<!-- d3 interpolate path -->
	<script src="https://unpkg.com/d3-interpolate-path@2.3.0/build/d3-interpolate-path.js"></script>
	

	<style>
         body {
             margin: 0;
             padding: 0;
             display: flex;
             height: 100vh;
             overflow: hidden;
	     background-color: #262A2B;
         }

         #menu {
             width: 60px;
             background-color: #CCC;
             color: #fff;
             padding: 20px;
             box-shadow: 2px 0px 5px rgba(0, 0, 0, 0.5);
             transition: width 0.3s ease;
             position: absolute;
             top: 0;
             bottom: 0;
             z-index: 2;
         }

         #menu.expanded {
             width: 250px;
         }

         #menu-button {
             cursor: pointer;
             z-index: 3;
             position: absolute;
             top: 20px;
             left: 20px;
         }

         #map-container {
             flex: 1;
	     position: relative;
             overflow: hidden;
         }

	</style>
    </head>
    <body>
	<div id="map-container">
            <svg id="geoJSONsvg_france"></svg>
	</div>
	
	<script>
	 
	 
         function toggleMenu() {
             const menu = document.getElementById("menu");
             const menuText = document.getElementById("menu-text");

             if (menu.classList.contains("expanded")) {
                 menu.classList.remove("expanded");
                 menuText.textContent = "M";
             } else {
                 menu.classList.add("expanded");
                 menuText.textContent = "Menu";
             }
         }

	 

	 const geoJSONfiles = [
	     "data/france.geo.json",
	     "data/river.geo.json",
	     "data/entiteHydro.geo.json"
	 ];

	 function loadGeoJSON(fileURL) {
	     return d3.json(fileURL)
		      .then(data => data)
		      .catch(error => {
			  console.error("Error loading geojson file :", error);
			  throw error;
		      });
	 }

	 const promises = geoJSONfiles.map(fileURL => loadGeoJSON(fileURL));

	 Promise.all(promises)
		.then(geoJSONdata => {
		    const geoJSONdata_france = geoJSONdata[0];
		    const geoJSONdata_river = geoJSONdata[1];
		    const geoJSONdata_entiteHydro = geoJSONdata[2];
		    drawGeoJSON(geoJSONdata_france, geoJSONdata_river, geoJSONdata_entiteHydro);
		})
		.catch(error => {
		    console.error("Error loading or processing GeoJSON files:", error);
		});

	 

	 function drawGeoJSON(geoJSONdata_france, geoJSONdata_river, geoJSONdata_entiteHydro) {
	     if (geoJSONdata_france && geoJSONdata_river) {
		 const width = 700;
		 const height = 700;

		 const fill_entiteHydro = "transparent";
		 const stroke_entiteHydro = "#555";
		 
		 const fill_france = "transparent";
		 const stroke_france = "#E8E6E3";
		 const stroke_river = "#9A9286";

		 const minZoom = 1;
		 const maxZoom = 4;
		 const maxPan = 0;

		 const transitionDuration = 500;
		 
		 const k_simplify_ref = 0.1;
		 let k_simplify;

		 const riverLength_max = 0.4;
		 const riverLength_min = 0;
		 let riverLength;		 

		 const zoom = d3.zoom()
				.scaleExtent([minZoom, maxZoom])
				.translateExtent([[-width*maxPan, -height*maxPan],
						  [width*(1+maxPan), height*(1+maxPan)]])
				.on("zoom", function (event) { 

				    riverLength = riverLength_max - (event.transform.k - minZoom)/(maxZoom-minZoom)*(riverLength_max-riverLength_min);
				    
				    k_simplify = k_simplify_ref + (event.transform.k - minZoom)/(maxZoom-minZoom)*(1-k_simplify_ref);
				    redrawMap(k_simplify, riverLength);

				    svg.attr("transform", event.transform);
				    svg.style("width", width * event.transform.k + "px");
				    svg.style("height", height * event.transform.k + "px");
				});


		 const projection = d3.geoMercator()
				      .scale([2200])
				      .center(geoJSONdata_france.features[0].properties.centroid)
				      .translate([width/2, height/2]);

		 const svg = d3.select("#geoJSONsvg_france")
			       .attr("width", width)
			       .attr("height", height)
			       .call(zoom)
			       .append("g");
		 
		 function redrawMap(k_simplify, riverLength) {
		     /* const simplifiedGeoJSON_entiteHydro = geotoolbox.simplify(geoJSONdata_entiteHydro, { k: k_simplify, merge: false }); */
		     const simplifiedGeoJSON_france = geotoolbox.simplify(geoJSONdata_france, { k: k_simplify, merge: false });

		     const selectedGeoJSON_river = geotoolbox.filter(geoJSONdata_river, (d) => d.norm >= riverLength);
		     const simplifiedselectedGeoJSON_river = geotoolbox.simplify(selectedGeoJSON_river, { k: k_simplify, merge: false });


		     /* svg.selectAll("path.entiteHydro")
			.data(simplifiedGeoJSON_entiteHydro.features)
			.join("path")
			.attr("class", "entiteHydro")
			.attr("d", pathGenerator)
			.attr("fill", fill_entiteHydro)
			.attr("stroke", stroke_entiteHydro)
			.attr("stroke-width", 0.8)
			.attr("stroke-linejoin", "round")
			.attr("stroke-miterlimit", 1); */
		     
		     svg.selectAll("path.france")
			.data(simplifiedGeoJSON_france.features)
			.join("path")
			.attr("class", "france")
			.attr("d", pathGenerator)
			.attr("fill", fill_france)
			.attr("stroke", stroke_france)
			.attr("stroke-width", 1)
			.attr("stroke-linejoin", "miter")
			.attr("stroke-miterlimit", 1);

		     const strokeWith_river_max = 0.9;
		     const strokeWith_river_min = 0.1;


		     svg.selectAll("path.river")
			.data(simplifiedselectedGeoJSON_river.features)
			.join("path")
			.attr("class", "river")
			.attr("d", pathGenerator)
			.transition()
			.duration(1000)
			.attr("fill", "transparent")
			.attr("stroke", stroke_river)
			.attr("stroke-width", function(d) {
			    return strokeWith_river_max - (1-d.properties.norm)*(strokeWith_river_max-strokeWith_river_min);
			})
		     /* .attr("stroke-width", 0.8) */
			.attr("stroke-linejoin", "miter")
			.attr("stroke-linecap", "round")
			.attr("stroke-miterlimit", 1);
		     
		 }

		 const pathGenerator = d3.geoPath(projection);

		 redrawMap(k_simplify_ref, riverLength_max);





		 /* let hoveredPolygon = null;

		    svg.selectAll("path.entiteHydro")
		    .data(geoJSONdata_entiteHydro.features)
		    .join("path")
		    .attr("class", "entiteHydro")
		    .attr("d", pathGenerator)
		    .attr("fill", fill_entiteHydro)
		    .attr("stroke", stroke_entiteHydro)
		    .attr("stroke-width", 0.8)
		    .attr("stroke-linejoin", "round")
		    .attr("stroke-miterlimit", 1)
		    .on("mouseover", function (event, d) {
		    hoveredPolygon = d;
		    updateDisplay();
		    })
		    .on("mouseout", function (event, d) {
		    hoveredPolygon = null;
		    updateDisplay();
		    });

		    function updateDisplay() {
		    svg.selectAll("path.entiteHydro")
		    .each(function (d) {
		    this.style.display = "none";
		    });

		    if (hoveredPolygon) {
		    const hoveredPath = svg.select(`[data-id="${hoveredPolygon.properties.id}"]`);
		    if (!hoveredPath.empty()) {
		    hoveredPath.style("display", "block");
		    }
		    }
		    } */



		 
		 
		 return svg.node();
		 
	     }
	 }
	 
	</script>
    </body>
</html>
